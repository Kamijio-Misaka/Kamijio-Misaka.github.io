[{"title":"关于AXI协议握手协议实现方式的一些理解","url":"/2025/03/05/%E5%85%B3%E4%BA%8EAXI%E5%8D%8F%E8%AE%AE%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","content":" AXI4握手协议\n\n 阻塞形单周期流水线的握手协议\n 阻塞形非单周期流水线的握手协议\n 总结一下~\n","tags":["Verilog","FPGA","AXI4"]},{"title":"hexo测试","url":"/2025/02/04/hexo-test/","content":"粗体测试测试\ncode span test\n斜体测试\n数学测试：\n∫0fs/2psd(f)df\\int_0^{fs/2}{psd\\left( f \\right) df}\n∫0fs/2​psd(f)df\n代码段测试\n#include &lt;stdio.c&gt;int main()&#123;    printf(&quot;hallo world!&quot;);    return 0;&#125;\nmodule ( input clk, input rstn, output sig )reg sig1;always @(posedge clk) begin    if(!rstn) begin        sig1 &lt;= 1&#x27;b0;    end else         sig1 &lt;= sig1;endassign sig = sig1;endmodule\n图片测试：\n\n\n","tags":["什么都不是"]},{"title":"脉动阵列矩阵乘加的Verilog实现","url":"/2025/03/05/%E8%84%89%E5%8A%A8%E9%98%B5%E5%88%97%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E7%9A%84Verilog%E5%AE%9E%E7%8E%B0/","content":" 脉动阵列基本原理\n 经典脉动阵列的基本原理\n以2x2矩阵和2x2矩阵的乘法为例。我们首先设置一个2x2的A矩阵和2x2的B矩阵。\n(a11a12a21a22)×(b11b12b21b22)=(a11∗b11+a12∗b21a11∗b12+a12∗b22b21∗b11+a22∗b21a21∗b12+a22∗b22)(1234)×(5678)=(19224350)\\left( \\begin{matrix}\n    a11&amp;a12\\\\\n    a21&amp;a22\n\\end{matrix} \\right) \\times \n\\left( \\begin{matrix}\n    b11&amp;b12\\\\\n    b21&amp;b22\n\\end{matrix} \\right) = \n\\left( \\begin{matrix}\n    a11*b11+a12*b21&amp;a11*b12+a12*b22\\\\\n    b21*b11+a22*b21&amp;a21*b12+a22*b22\n\\end{matrix} \\right)\\newline \n\\newline\n\\left( \\begin{matrix}\n    1&amp;2\\\\\n    3&amp;4\n\\end{matrix} \\right) \\times \n\\left( \\begin{matrix}\n    5&amp;6\\\\\n    7&amp;8\n\\end{matrix} \\right) = \n\\left( \\begin{matrix}\n    19&amp;22\\\\\n    43&amp;50\n\\end{matrix} \\right)\\\\\n(a11a21​a12a22​)×(b11b21​b12b22​)=(a11∗b11+a12∗b21b21∗b11+a22∗b21​a11∗b12+a12∗b22a21∗b12+a22∗b22​)(13​24​)×(57​68​)=(1943​2250​)\n计算的基本流程如下：\n\n输入矩阵A整形为菱形后逐列输入到脉动阵列中；输入矩阵B整形为菱形后逐行输入。\n每个PE单元执行如下运算：\n{Dn=An−1×Bn−1+Dn−1OUTright=An−1OUTdown=Bn−1\\left\\{ \\begin{array}{l}\n\tD_n=A_{n-1}\\times B_{n-1}+D_{n-1}\\\\\n\tOUT_{right}=A_{n-1}\\\\\n\tOUT_{down}=B_{n-1}\\\\\n\\end{array} \\right. \n⎩⎪⎨⎪⎧​Dn​=An−1​×Bn−1​+Dn−1​OUTright​=An−1​OUTdown​=Bn−1​​\nDnD_nDn​为第n个时刻PE单元计算的结果。An−1,Bn−1A_{n-1}, B_{n-1}An−1​,Bn−1​是第n-1时刻的A矩阵和B矩阵的输入值，也就是经过寄存器打拍的A矩阵和B矩阵输入值。\n每单个PE单元执行的相乘、累加操作并以脉动的方式将结果贮存在PE单元内部。\n google改进的脉动阵列\n\n传统的脉动阵列采用的脉动结构是：数据流动、权重流动、结果存储。\ngoogle改进后的采用的脉动阵列结构是：数据流动、权重存储、结果流动。\n\n两种脉动阵列的PE单元有着明显的区别，如下图。\n\n两种PE单元会导致两种脉动阵列的矩阵输入输出方式的不同，从而导致资源消耗和critical path的不同。\n对于google的权重加载型的脉动阵列，输入数据按照逐列输入，权重W也就是B矩阵需要提前加载。其基本工作流程如下图所示：\n\n该种方式相对比经典脉动结构在计算单次矩阵时会有更长的延时，但是当计算大规模的矩阵时，提前加载的权重会使矩阵数据输入到脉动阵列的时间间断一半。大大提高效率。同时，结果存储型的脉动阵列在输出结果时，需要使用一个大规模的选择器输出，会出现一个很长的组合逻辑延时，从而降低吞吐率。如下图。\n\n同时，由于权重加载的PE单元存在一个加法输入端，因此其不仅可以实现矩阵乘法，更可以实现矩阵加法。\n 脉动阵列实现\n 8bit运算的PE单元\nPE单元采用权重加载形的PE单元，基本架构如下图。\n\n\n红色方块Weight loader controler用于控制权重数据的载入；\n蓝色方块data Register和Weight Register用于寄存输入的计算数据和权重数据；\n绿色方块分别代表乘法和加法的计算模块；\n黄色圆圈是输入输出的数据端口，其中control signal用来发送控制信号。\n\n设计时序图如下图所示：\n\n\n当PE单元输入权重值w11和和w21时，PE单元会存储第一个输入的w11，然后将下一个输入进来的权重w21直接传递给垂直方向的下一级PE单元；\n左侧输入数据打一拍进入乘法器并输入给水平方向的下一级(右侧)PE单元；\n上侧输入数据需要控制时序和乘法器输出对齐。加法器输入数据的延迟在外部数据加载器实现；\n输出的乘法器和加法数据之和经过一级打拍输出给垂直方向的下一级PE单元。\n\n实现代码如下：\nmodule pe#(    parameter MAX_DATA_WIDTH = 8,    parameter MULTIPLIER_PIPLINE = 1)(    // global signal    input                           clk,     input                           rstn,        // Weight loader signal    input [MAX_DATA_WIDTH-1:0]      weight_i,    input                           weight_vld_i,    output                          weight_rdy_o,    // Weight output signal    output [MAX_DATA_WIDTH-1:0]     weight_nxt_o,    output                          weight_nxt_vld_o,        // control signal    input                           weight_clr_i,        // input data and input flow control    input [MAX_DATA_WIDTH-1:0]      data_i,    input                           data_vld_i,        // output data and output flow control    output [MAX_DATA_WIDTH-1:0]     data_o,    output                          data_vld_o,        // adder signal input and output and flow control    input [4*MAX_DATA_WIDTH-1:0]    add_data_i,    input                           add_vld_i,    output [4*MAX_DATA_WIDTH-1:0]   add_data_o,    output                          add_vld_o);/***** parameter declare region *****//***** signal declare region *****/// regreg [MAX_DATA_WIDTH-1:0]            r_weight_nxt_o;reg                                 r_weight_nxt_vld_o;reg                                 r_weight_vld;reg [MAX_DATA_WIDTH-1:0]            weight_reg;reg [MAX_DATA_WIDTH-1:0]            r_data_o    ;reg                                 r_data_vld_o;reg [4*MAX_DATA_WIDTH-1:0]          r_add_data_o;reg                                 r_add_vld_o;// wirewire                                weight_nxt_en;wire [2*MAX_DATA_WIDTH-1:0] \t    mult_out;wire                    \t        mult_vld_out;wire                                mult_in_vld;wire [MAX_DATA_WIDTH-1:0]           mult_data1_in;wire [MAX_DATA_WIDTH-1:0]           mult_data2_in;/***** conbination logic circuit region *****/assign weight_rdy_o     = (!r_weight_vld) &amp; weight_vld_i;assign weight_nxt_o     = weight_i;assign weight_nxt_vld_o = !weight_rdy_o &amp; weight_vld_i;assign data_o           = r_data_o    ;assign data_vld_o       = r_data_vld_o;assign mult_data1_in    = weight_reg;assign mult_data2_in    = r_data_o;assign mult_in_vld      = (!weight_rdy_o) &amp; r_data_vld_o;assign add_data_o       = r_add_data_o;assign add_vld_o        = r_add_vld_o;/***** sequential logic circuit region *****/always @(posedge clk) begin    if(!rstn) begin        r_weight_vld &lt;= 1&#x27;b0;    end else begin        r_weight_vld &lt;= weight_vld_i;    end endalways @(posedge clk) begin    if(!rstn) begin        weight_reg &lt;= &#x27;b0;    end else if (weight_clr_i) begin        weight_reg &lt;= &#x27;b0;    end else if (weight_rdy_o) begin        weight_reg &lt;= weight_i;    end else begin        weight_reg &lt;= weight_reg;    endendalways @(posedge clk) begin    if(!rstn) begin        r_weight_nxt_o &lt;= &#x27;b0;        r_weight_nxt_vld_o &lt;= &#x27;b0;    end else if((!weight_rdy_o) &amp; weight_vld_i) begin        r_weight_nxt_o &lt;= weight_i;        r_weight_nxt_vld_o &lt;= 1&#x27;b1;    end else begin        r_weight_nxt_o &lt;= r_weight_nxt_o;        r_weight_nxt_vld_o &lt;= 1&#x27;b0;    endendalways @(posedge clk) begin    if(!rstn) begin        r_data_o     &lt;= &#x27;b0;        r_data_vld_o &lt;= &#x27;b0;    end else begin        r_data_o     &lt;= data_i;        r_data_vld_o &lt;= data_vld_i;    endendalways @(posedge clk) begin    if(!rstn) begin        r_add_data_o &lt;= &#x27;b0;        r_add_vld_o  &lt;= &#x27;b0;    end else begin        r_add_data_o &lt;= $signed(mult_out) + $signed(add_data_i);        r_add_vld_o  &lt;= mult_vld_out &amp; add_vld_i;    endend/***** Instance region *****/// outports wiremultiplier #(\t.DATA_WIDTH \t    ( MAX_DATA_WIDTH  ),    .MULTIPLIER_PIPLINE ( MULTIPLIER_PIPLINE))u_multiplier(\t.clk          \t    ( clk           ),\t.rstn         \t    ( rstn          ),\t.data1_i      \t    ( mult_data1_in ),\t.data2_i      \t    ( mult_data2_in ),\t.data_vld_i   \t    ( mult_in_vld   ),\t.result_o     \t    ( mult_out      ),\t.result_vld_o \t    ( mult_vld_out  ));endmodule\n PE array\n一个4x4的PE阵列架构图让如下图所示。\n\n脉动阵列数据加载器的本质就是将每一行输入数据进行延迟，因此只需要使用多个寄存器打拍即可。输出数据同理使其变为方形的数据。由于采用的乘法器为一级流水线乘法器，因此在实现时，输入的求和C矩阵需要延迟两排使其在时序上与乘法器的输出对齐。结构如下图。\n\n设计实现代码如下所示：\n`timescale 1ns / 1psmodule systolic_array#(    parameter MAX_DATA_WIDTH = 8,    parameter MULTIPLIER_PIPLINE = 1,    parameter ROW_NUM = 4,    parameter COL_NUM = 4    )(    // global signal    input                                   clk,    input                                   rstn,    // weight loader    input [COL_NUM*MAX_DATA_WIDTH-1:0]      weight_i,    input                                   weight_vld_i,    input                                   weight_clr,    // adder input    input [COL_NUM*4*MAX_DATA_WIDTH-1:0]    adder_i,    input [0:COL_NUM-1]                     adder_vld_i,    // data input    input [ROW_NUM*MAX_DATA_WIDTH-1:0]      left_i,    input [0:ROW_NUM-1]                     left_vld_i,    //out colume data    output [COL_NUM*4*MAX_DATA_WIDTH-1:0]   data_o,    output [0:COL_NUM-1]                    data_vld_o    );        /*** signal declare region ***/    // PE array internal connection signals    wire [MAX_DATA_WIDTH-1:0]   data_links          [0:ROW_NUM-1][0:COL_NUM]; // Horizontal connection    wire                        data_vld_links      [0:ROW_NUM-1][0:COL_NUM];    wire [MAX_DATA_WIDTH-1:0]   weight_links        [0:ROW_NUM][0:COL_NUM-1]; // Vertical connection    wire                        weight_vld_links    [0:ROW_NUM][0:COL_NUM-1];    wire [4*MAX_DATA_WIDTH-1:0] adder_links         [0:ROW_NUM][0:COL_NUM-1]; // out connection    wire                        adder_vld_links     [0:ROW_NUM][0:COL_NUM-1]; // out connection    // delay register connection signals    wire [MAX_DATA_WIDTH-1:0]   left_r              [0:ROW_NUM-1];    wire                        left_vld_r          [0:ROW_NUM-1];    wire [4*MAX_DATA_WIDTH-1:0] adder_r             [0:COL_NUM-1];    wire                        adder_vld_r         [0:COL_NUM-1];    wire [4*MAX_DATA_WIDTH-1:0] result_out          [0:COL_NUM-1];    wire                        result_vld          [0:COL_NUM-1];    // output signal region    wire [COL_NUM*4*MAX_DATA_WIDTH-1:0]   wire_data_o;    wire [0:COL_NUM-1]                    wire_data_vld_o;        /*** combination ***/    assign data_o = wire_data_o;        assign data_vld_o = wire_data_vld_o;        /*** delay register generation ***/    generate        // left data input delay        genvar sf_row;        genvar sf_col;        genvar k;        for (sf_row = 0; sf_row &lt; ROW_NUM; sf_row = sf_row + 1) begin : row_delay            shift_reg #(                .DATA_WIDTH  \t( MAX_DATA_WIDTH  ),                .SHIFT_LEVEL \t( sf_row + 1   ))            u_shift_reg(                .clk          \t( clk                   ),                .rstn         \t( rstn                  ),                .data_i       \t( left_i[(ROW_NUM*MAX_DATA_WIDTH-sf_row*MAX_DATA_WIDTH)-1 -: MAX_DATA_WIDTH]   ),                .data_valid_i \t( left_vld_i[sf_row]    ),                .data_o       \t( left_r[sf_row]        ),                .data_valid_o \t( left_vld_r[sf_row]    )            );        end        // adder input delay        for (sf_col = 0; sf_col &lt; COL_NUM; sf_col = sf_col + 1) begin : adder_in_delay            shift_reg #(                    .DATA_WIDTH  \t( MAX_DATA_WIDTH  ),                    .SHIFT_LEVEL \t( MULTIPLIER_PIPLINE+1 +  sf_col + 1  ))                u_shift_reg(                    .clk          \t( clk                               ),                    .rstn         \t( rstn                              ),                    .data_i       \t( adder_i[(COL_NUM*MAX_DATA_WIDTH-sf_col*MAX_DATA_WIDTH)-1 -: MAX_DATA_WIDTH]      ),                    .data_valid_i \t( adder_vld_i[sf_col]               ),                    .data_o       \t( adder_r[sf_col]                   ),                    .data_valid_o \t( adder_vld_r[sf_col]               )                );        end        // data output delay        for (sf_col = 0; sf_col &lt; COL_NUM; sf_col = sf_col + 1) begin : out_delay            shift_reg #(                .DATA_WIDTH  \t( 4*MAX_DATA_WIDTH  ),                .SHIFT_LEVEL \t( COL_NUM - sf_col -1  ))            u_shift_reg(                .clk          \t( clk                               ),                .rstn         \t( rstn                              ),                .data_i       \t( adder_links[ROW_NUM][sf_col]      ),                .data_valid_i \t( adder_vld_links[ROW_NUM][sf_col]  ),                .data_o       \t( result_out[sf_col]                ),                .data_valid_o \t( result_vld[sf_col]                )            );        end        // Generate output logic        for (k = 0; k &lt; COL_NUM; k = k + 1) begin : out_gen            assign wire_data_o[(COL_NUM-k)*4*MAX_DATA_WIDTH-1 -: 4*MAX_DATA_WIDTH] = result_out[k];            assign wire_data_vld_o[k] = result_vld[k];        end    endgenerate    /*** PE array generation ***/    generate        genvar i, j, l;                 // Generate input data splitting logic        for (i = 0; i &lt; ROW_NUM; i = i + 1) begin : data_row_split            assign data_links[i][0] = left_r[i];            assign data_vld_links[i][0] = left_vld_r[i];         end            // Generate input weight splitting logic        for (j = 0; j &lt; COL_NUM; j = j + 1) begin : weight_col_split            assign weight_links[0][j] = weight_i[(COL_NUM*MAX_DATA_WIDTH-j*MAX_DATA_WIDTH)-1 -: MAX_DATA_WIDTH];            assign weight_vld_links[0][j] = weight_vld_i;        end        // Generate input adder data splitting logic        for (l = 0; l &lt; ROW_NUM; l = l + 1) begin : adder_col_split            assign adder_links[0][l] = adder_r[l];            assign adder_vld_links[0][l] = adder_vld_r[l];         end            // Generating PE array        for (i = 0; i &lt; ROW_NUM; i = i + 1) begin : row_gen            for (j = 0; j &lt; COL_NUM; j = j + 1) begin : col_gen                // outports wire                pe #(                    .MAX_DATA_WIDTH \t( MAX_DATA_WIDTH  ),                    .MULTIPLIER_PIPLINE ( MULTIPLIER_PIPLINE))                u_pe(                    // global signal                    .clk              \t( clk                       ),                    .rstn             \t( rstn                      ),                    // weight loader signal                    .weight_i         \t( weight_links[i][j]        ),                    .weight_vld_i     \t( weight_vld_links[i][j]    ),                    .weight_rdy_o     \t(                           ),                    .weight_clr_i     \t( weight_clr_i              ),                    // weight output signal                    .weight_nxt_o     \t( weight_links[i+1][j]      ),                    .weight_nxt_vld_o \t( weight_vld_links[i+1][j]  ),                    // data input signal                    .data_i           \t( data_links[i][j]          ),                    .data_vld_i       \t( data_vld_links[i][j]      ),                    // data output signal                    .data_o           \t( data_links[i][j+1]        ),                    .data_vld_o       \t( data_vld_links[i][j+1]    ),                    // adder data input signal                    .add_data_i       \t( adder_links[i][j]         ),                    .add_vld_i        \t( adder_vld_links[i][j]     ),                    // adder data output signal                    .add_data_o       \t( adder_links[i+1][j]       ),                    .add_vld_o        \t( adder_vld_links[i+1][j]   )                );            end        end    endgenerate    endmodule\n 仿真结果验证\n蓝色波形为输出结果，黄色波形为实际计算结果，可见结果正确。\n\n","tags":["Verilog","FPGA","TPU","脉动阵列"]}]